import { DocumentInitParameters } from 'pdfjs-dist/types/src/display/api.js';
import type { ImageKind } from 'pdfjs-dist/legacy/build/pdf.mjs';
import { Metadata } from 'pdfjs-dist/types/src/display/metadata.js';
import { PDFDataRangeTransport } from 'pdfjs-dist/types/src/display/api.js';
import { PDFWorker } from 'pdfjs-dist/types/src/display/api.js';
import { TypedArray } from 'pdfjs-dist/types/src/display/api.js';
import { VerbosityLevel } from 'pdfjs-dist/legacy/build/pdf.mjs';

/**
 * Consolidated date information gathered from different PDF sources.
 * The PDF 'Info' dictionary contains CreationDate / ModDate and
 * the XMP/XAP metadata can contain several timestamps as well. This
 * structure collects those values (if present) as JavaScript Date objects
 * or null when the property exists but cannot be parsed.
 */
export declare type DateNode = {
    CreationDate?: Date | null;
    ModDate?: Date | null;
    XmpCreateDate?: Date | null;
    XmpModifyDate?: Date | null;
    XmpMetadataDate?: Date | null;
    XapCreateDate?: Date | null;
    XapModifyDate?: Date | null;
    XapMetadataDate?: Date | null;
};

export { DocumentInitParameters }

/**
 * EmbeddedImage
 * - Normalized representation of an embedded image extracted from the PDF.
 * - `data`: Raw image bytes (e.g. PNG/JPEG) as Uint8Array. Use this for file writing or binary processing.
 * - `dataUrl`: Optional data URL (e.g. "data:image/png;base64,...") for directly embedding in <img> src.
 *   Storing both lets consumers choose the most convenient form; consider omitting one to save memory.
 * - `name`: Resource name for the image.
 * - `width` / `height`: Dimensions in pixels.
 * - `kind`: ImageKindValue from indicating the pixel format (e.g. GRAYSCALE_1BPP / RGB_24BPP / RGBA_32BPP).
 */
export declare interface EmbeddedImage {
    data: Uint8Array;
    dataUrl: string;
    name: string;
    width: number;
    height: number;
    kind: ImageKindValue;
}

/**
 * Perform an HTTP HEAD request to retrieve the file size and verify existence;
 * when `check` is true, fetch a small range and inspect the magic number to confirm the URL points to a valid PDF.
 * If the server does not support range requests, `isPdf` will be set to `false`.
 * @param url The URL of the PDF file to check. Can be a string or URL object.
 * @param check When `true`, download a small byte range (first 4 bytes) to validate the file signature by checking for '%PDF' magic bytes. Default: `false`.
 * @returns A Promise that resolves to a HeaderResult object containing the response status, size, headers, and PDF validation result.
 */
export declare function getHeader(url: string | URL, check?: boolean): Promise<HeaderResult>;

export declare interface HeaderResult {
    ok: boolean;
    status?: number;
    size?: number;
    isPdf?: boolean;
    headers?: Record<string, string>;
    error?: Error;
}

/**
 * ImageKindKey
 * - Represents the keys of the ImageKind enum (e.g. "GRAYSCALE_1BPP", "RGB_24BPP", "RGBA_32BPP").
 */
export declare type ImageKindKey = keyof typeof ImageKind;

/**
 * ImageKindValue
 * - Represents the numeric values of the ImageKind enum (e.g. 1, 2, 3).
 */
export declare type ImageKindValue = (typeof ImageKind)[ImageKindKey];

export declare class ImageResult {
    pages: Array<PageImages>;
    total: number;
    getPageImage(num: number, name: string): EmbeddedImage | null;
    constructor(total: number);
}

/**
 * Aggregated information about a PDF document returned by getInfo().
 * The object contains high-level metadata, outline/bookmark structure,
 * per-page extracted hyperlinks and utility helpers for parsing dates.
 */
export declare class InfoResult {
    total: number;
    /**
     * The PDF 'Info' dictionary. Typical fields include title, author, subject,
     * Creator, Producer and Creation/Modification dates. The exact structure is
     * determined by the PDF and as returned by PDF.js.
     */
    info?: any;
    metadata?: Metadata;
    /**
     * An array of document fingerprint strings provided by PDF.js. Useful
     * for caching, de-duplication or identifying a document across runs.
     */
    fingerprints?: Array<string | null>;
    /**
     * Permission flags for the document as returned by PDF.js (or null).
     * These flags indicate capabilities such as printing, copying and
     * other restrictions imposed by the PDF security settings.
     */
    permission?: number[] | null;
    /**
     * Optional document outline (bookmarks). When present this is the
     * hierarchical navigation structure which viewers use for quick access.
     */
    outline?: Array<OutlineNode> | null;
    pages: Array<PageLinkResult>;
    /**
     * Collects dates from different sources (Info dictionary and XMP/XAP metadata)
     * and returns them as a DateNode where available. This helps callers compare
     * and choose the most relevant timestamp (for example a creation date vs XMP date).
     */
    getDateNode(): DateNode;
    /**
     * Try to parse an ISO-8601 date string from XMP/XAP metadata. If the
     * value is falsy or cannot be parsed, undefined is returned to indicate
     * absence or unparsable input.
     */
    private parseISODateString;
    constructor(total: number);
}

export { Metadata }

/**
 * Node representing a single item in the PDF outline (bookmarks).
 * This mirrors the structure returned by PDF.js' getOutline() API.
 */
export declare interface OutlineNode {
    title: string;
    bold: boolean;
    italic: boolean;
    color: Uint8ClampedArray;
    dest: string | Array<any> | null;
    url: string | null;
    unsafeUrl?: string;
    newWindow?: boolean;
    count?: number;
    items: Array<any>;
}

/**
 * PageImages
 * - Represents all embedded images found on a single PDF page.
 * - pageNumber: 1-based page index.
 * - images: Array of EmbeddedImage objects for this page.
 */
export declare interface PageImages {
    pageNumber: number;
    images: EmbeddedImage[];
}

/**
 * Per-page link extraction result.
 * - pageNumber: the physical page index (1-based) within the PDF document.
 * - pageLabel: optional printed page label shown by PDF viewers (e.g. "iii", "1", "A-1");
 *              this can differ from the physical page number and may be undefined
 *              when the document does not provide labels.
 * - links: array of text->URL mappings that were found/overlaid on the page.
 * - width/height: page dimensions in PDF units for the viewport used.
 */
export declare type PageLinkResult = {
    pageNumber: number;
    pageLabel?: string | null;
    links: Array<{
        text: string;
        url: string;
    }>;
    width: number;
    height: number;
};

export declare interface PageTableResult {
    num: number;
    tables: Array<Array<string>>;
}

export declare interface PageTextResult {
    num: number;
    text: string;
}

export declare interface ParseParameters {
    /**
     * Array of page numbers to parse.
     * When provided, only these pages will be parsed and returned in the same order.
     * Example: [1, 3, 5]. Parse only one page: [7].
     * Default: `undefined`.
     */
    partial?: Array<number>;
    /**
     * Parse the first N pages (pages 1..N).
     * Ignored when `partial` is provided. If both `first` and `last` are set, they define
     * an explicit inclusive page range (first..last) and this "first N" semantics is ignored.
     * Default: `undefined`.
     */
    first?: number;
    /**
     * Parse the last N pages (pages total-N+1..total).
     * Ignored when `partial` is provided. If both `first` and `last` are set, they define
     * an explicit inclusive page range (first..last) and this "last N" semantics is ignored.
     * Default: `undefined`.
     */
    last?: number;
    /**
     * Collect per-page metadata such as embedded links, title, pageLabel, and dimensions;
     * ISBN, DOI, abstract, and references are work in progress when getInfo() is used.
     * Default: `false`.
     */
    parsePageInfo?: boolean;
    /**
     * Attempt to detect and include hyperlink annotations (e.g. URLs) associated with text.
     * Detected links are formatted as Markdown inline links (for example: [text](https://example.com)).
     * Default: `false`.
     */
    parseHyperlinks?: boolean;
    /**
     * Enforce logical line breaks by inserting a newline when the vertical distance
     * between text items exceeds `lineThreshold`.
     * Useful to preserve paragraph/line structure when text items are emitted as separate segments.
     * Default: `true`.
     */
    lineEnforce?: boolean;
    /**
     * Threshold to decide whether nearby text items belong to different lines.
     * Larger values make the parser more likely to start a new line between items.
     * Default: `4.6`.
     */
    lineThreshold?: number;
    /**
     * String inserted between text items on the same line when a sufficiently large horizontal gap is detected.
     * Typically used to emulate a cell/column separator (for example, "\\t" for tabs).
     * Default: `'\t'`.
     */
    cellSeparator?: string;
    /**
     * Horizontal distance threshold to decide when two text items on the same baseline should be treated as separate cells.
     * Larger value produces fewer (wider) cells; smaller value creates more cell breaks.
     * Default: `7`.
     */
    cellThreshold?: number;
    /**
     * Optional string appended at the end of each page's extracted text to mark page boundaries.
     * Supports placeholders `page_number` and `total_number` which are substituted accordingly.
     * If omitted or empty, no page boundary marker is added.
     * Default: `'\n-- page_number of total_number --'`.
     */
    pageJoiner?: string;
    /**
     * Optional string used to join text items when returning a page's text.
     * If provided, this value is used instead of the default empty-string joining behavior.
     * Default: `undefined`.
     */
    itemJoiner?: string;
    /**
     * Minimum image dimension (in pixels) for width or height.
     * When set, images where width OR height are below or equal this value will be ignored by `getImage()`.
     * Useful for excluding tiny decorative or tracking images.
     * Default: `80`.
     * Disable: `0`.
     */
    imageThreshold?: number;
    /**
     * Screenshot scale factor: use 1 for the original size, 1.5 for a 50% larger image, etc.
     * Default: `1`.
     */
    scale?: number;
    /**
     * Desired screenshot width in pixels.
     * When set, the scale option is ignored.
     * Default: `undefined`.
     */
    desiredWidth?: number;
    /**
     * Applies to both getImage() and getScreenshot(): include the image as a base64 data URL string.
     * Default: `true`.
     */
    imageDataUrl?: boolean;
    /**
     * Applies to both getImage() and getScreenshot(): include the image as a binary buffer.
     * Default: `true`.
     */
    imageBuffer?: boolean;
    /**
     * Include marked content items in the items array of TextContent to capture PDF "marked content".
     * Enables tags (MCID, role/props) and structural/accessibility information useful for mapping text â†” structure.
     * For plain text extraction it's usually false (trade-off: larger output).
     * Default: `false`.
     */
    includeMarkedContent?: boolean;
    /**
     * When true, text normalization is NOT performed in the worker thread.
     * For plain text extraction, normalizing in the worker (false) is usually recommended.
     * Default: `false`.
     */
    disableNormalization?: boolean;
}

export { PDFDataRangeTransport }

/**
 * Loads PDF documents and exposes helpers for text, image, table, metadata, and screenshot extraction.
 */
export declare class PDFParse {
    private readonly options;
    private doc;
    progress: {
        loaded: number;
        total: number;
    };
    /**
     * Create a new parser with `DocumentInitParameters`.
     * Converts Node.js `Buffer` data to `Uint8Array` automatically and ensures a default verbosity level.
     * @param options Initialization parameters.
     */
    constructor(options: DocumentInitParameters);
    destroy(): Promise<void>;
    static get isNodeJS(): boolean;
    static setWorker(workerSrc?: string): string;
    /**
     * Perform an HTTP HEAD request to retrieve the file size and verify existence;
     * when `check` is true, fetch a small range and inspect the magic number to confirm the URL points to a valid PDF.
     * @param check When `true`, download a small byte range to validate the file signature.
     * Default: `false`.
     */
    getHeader(check?: boolean): Promise<HeaderResult>;
    /**
     * Load document-level metadata (info, outline, permissions, page labels) and optionally gather per-page link details.
     * @param params Parse options; set `parsePageInfo` to collect per-page metadata described in `ParseParameters`.
     * @returns Aggregated document metadata in an `InfoResult`.
     */
    getInfo(params?: ParseParameters): Promise<InfoResult>;
    private getPageLinks;
    /**
     * Extract plain text for each requested page, optionally enriching hyperlinks and enforcing line or cell separators.
     * @param params Parse options controlling pagination, link handling, and line/cell thresholds.
     * @returns A `TextResult` containing page-wise text and a concatenated document string.
     */
    getText(params?: ParseParameters): Promise<TextResult>;
    private load;
    private shouldParse;
    private getPageText;
    private getHyperlinks;
    /**
     * Extract embedded images from requested pages.
     *
     * Behavior notes:
     * - Pages are selected according to ParseParameters (partial, first, last).
     * - Images smaller than `params.imageThreshold` (width OR height) are skipped.
     * - Returned ImageResult contains per-page PageImages; each image entry includes:
     *     - data: Uint8Array (present when params.imageBuffer === true)
     *     - dataUrl: string (present when params.imageDataUrl === true)
     *     - width, height, kind, name
     * - Works in both Node.js (canvas.toBuffer) and browser (canvas.toDataURL) environments.
     *
     * @param params ParseParameters controlling page selection, thresholds and output format.
     * @returns Promise<ImageResult> with extracted images grouped by page.
     */
    getImage(params?: ParseParameters): Promise<ImageResult>;
    private convertToRGBA;
    private resolveEmbeddedImage;
    /**
     * Render pages to raster screenshots.
     *
     * Behavior notes:
     * - Pages are selected according to ParseParameters (partial, first, last).
     * - Use params.scale for zoom; if params.desiredWidth is specified it takes precedence.
     * - Each ScreenshotResult page contains:
     *     - data: Uint8Array (when params.imageBuffer === true)
     *     - dataUrl: string (when params.imageDataUrl === true)
     *     - pageNumber, width, height, scale
     * - Works in both Node.js (canvas.toBuffer) and browser (canvas.toDataURL) environments.
     *
     * @param parseParams ParseParameters controlling page selection and render options.
     * @returns Promise<ScreenshotResult> with rendered page images.
     */
    getScreenshot(parseParams?: ParseParameters): Promise<ScreenshotResult>;
    /**
     * Detect and extract tables from pages by analysing vector drawing operators, then populate cells with text.
     *
     * Behavior notes:
     * - Scans operator lists for rectangles/lines that form table grids (uses PathGeometry and LineStore).
     * - Normalizes detected geometry and matches positioned text to table cells.
     * - Honors ParseParameters for page selection.
     *
     * @param params ParseParameters controlling which pages to analyse (partial/first/last).
     * @returns Promise<TableResult> containing discovered tables per page.
     */
    getTable(params?: ParseParameters): Promise<TableResult>;
    private getPathGeometry;
    private getPageTables;
    private fillPageTables;
}

export { PDFWorker }

export declare interface Screenshot {
    data: Uint8Array;
    dataUrl: string;
    pageNumber: number;
    width: number;
    height: number;
    scale: number;
}

export declare class ScreenshotResult {
    pages: Array<Screenshot>;
    total: number;
    constructor(total: number);
}

export declare class TableResult {
    pages: Array<PageTableResult>;
    mergedTables: Array<Array<string>>;
    total: number;
    constructor(total: number);
}

export declare class TextResult {
    pages: Array<PageTextResult>;
    text: string;
    total: number;
    getPageText(num: number): string;
    constructor(total: number);
}

export { TypedArray }

export { VerbosityLevel }

export { }
